---------sumary---------
如今的操作系统大多采用一种粗粒度的方式（也就是以页表作为基本单位的）来对内容、权限进行区分，这样的方式能够保证一定的安全性，但是对于不同的进程来说，来回换页会导致很大的性能开销，那就更不可能在这些页中做更细粒度的划分了，因为这对于处理器和物理内存来说都是极大地耗损，但不容置疑的是，细粒度的划分有助于提供操作系统更加全面的保护。而对于程序中对不合法地址的引用的问题来说，不应该是由程序员对他们所持有的变量进行保护，而是应该由一套完整的方案（包括软硬件）来对这种安全问题进行统一防范。
对于系统的内存空间来说，引用一个超出边界的数组或缓存都是造成出现错误、导致安全隐患的主要原因，所以如何避免人们通过挖掘这些非法引用来达到破坏操作系统的目的是目前需要面对的主要问题，本文试图提出一种叫做low-fat pointers的方式来对那些非法或者合法的指针的边界进行检查，而且这种检查边界的方式是通过额外的硬件来强制执行的，这种方式是不可伪造的，且由于硬件是以并行的方式与处理器进行协同处理的，所以不会产生额外的overhead。
作者提出的low-fat pointers方式所做出的新颖贡献：
1.设计和分析了紧密型fat-pointer的编码、实现方式，保证较少的空间碎片，和准确的空间边界检查。
2.配套的硬件使这种安全检查是无法伪造且无法绕过的。
3.流水线的组织使这种安全检查是快速的，不会造成处理器额外的性能耗损。
对于本文做出的对fat-pointers编码方式的改进，它采用如下方式进行实现：对于之前的浮点数来说，由于内存空间的对齐要求总是对齐到2的幂上，所以当一个数据刚好结束在2的幂+1的位置上时，会因此浪费近乎一半的空间，这对与内存空间来说是庞大的内部碎片，作者提出的紧密型fat-pointer则是通过分块的方式来使这种对齐方式的基本单位减小，他可以将数据分割成以2的大小为单位的小块，通过数据前部的一段编码来描述这些小块的组成方式和所代表的内容，从而将内存的对齐单位减小到2，有效的减少内部碎片。
为了比较作者所提出的BIMA的fat-pointer编码方式，作者选用了Aries这种fat-pointer编码方式来做对比的实验分析。Aries与BIMA的fat-pointer的编码方式是不同的，BIMA在pointer中加入的作为安全检查的参数为基址和他的边界，而Aries采用的参数则为基址和数据长度，区别在于如何描述这些参数的位置信息呢，Aries采用的是offset的方式对这些参数进行描述，这个在解码的时候将带来更大的性能开销。作者也在4.9节对BIMA的不同性能在不同环境参数下进行测量，一般BMIA的解码、更新随着地址位数的增加，都伴随着延迟和所使用空间（LUT）的上升，而对于Aries和BIMA的比较来说，在地址长度为32-64位的这段范围中，Aries相较于BIMA都要有较大的延迟。
---------comment---------
BIMA所提出的这种对fat-pointer的紧密型编码方式能够很好的减少他的空间碎片，但是算是对以往Aries的一种补充和修改，修改了对指针参数的方式，也对相应的硬件做了修改从而达到比Aries更高效的解码编码方式，但是在文章的对实验的评价部分，缺少对Aries和BIMA的大量的实验比较，只提供了一种在相同地址位数的情况下Aries和BIMA的延迟的比较我想是不够的，在实验分析部分大多数是对BMIA自身的性能比较，缺乏较强的说服力。