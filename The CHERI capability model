The CHERI capability model: Revisiting RISC in an age of risk
————————————summary————————————
    本文提出了一个叫做CHERI的一种内存保护机制，CHERI是一种基于capability的模型，他是基于RISC的思想而构建的，与其他过去的机遇capability的model相比，CHERI采用了专属的基于字节的保护，且兼容了现在普遍使用的基于页的保护，这使CHERI对已经大量存在的架构以至于基于这些架构所编写的一些上层应用都有很强的兼容性。
    以往的内存保护机制都是基于页面进行保护的，比如说对一个页维护它所能够被行使的权限（写保护等权限），以页进行划分对于操作系统来说是非常有用的划分，该划分是为了更好的实现对应用程序所能够访问到的内容进行权限划分、错误隔离，但是这种粗粒度的划分是不够的，他对于程序中的栈可能会出现的错误、或者被别人利用的漏洞没办法很好的防护，最典型的就是一些buffer overflow的漏洞利用，一般都是因为软件、硬件层面没有对各个变量的边界进行有效的保护，这对于粗粒度的保护来说往往不能起到很好的防护效果，而CHERI则是在提供这种粗粒度的保护同时提供一种细粒度的保护，它能够有效的记录应用所使用的内存的边界，提供这种细粒度的内存保护，经过测试后体现CHERI在性能和安全性上都有很好的表现。
    CHERI最终被作者实现于基于RISC的MIPS Ⅳ的处理器架构上，它对内存的保护是通过类似于页中的权限控制来实现的，它提供了一套关于内存的capability，该capability一共有256位的空间，有31位的权限码用来控制对这一小块内存的访问、读写等权限进行限制，还有一个64位的基址来描述这块内存的访问地址，一个64位的数据描述这块内存的长度。
    对于该类保护机制来说，最大的挑战在于如何在不用请求内核进行系统调用将这一保护机制实现，因为对于频繁需要对内存进行标记的操作来说，如果总是需要由内核进行操作必将引入大量的性能开销。CHERI对内存的标记是对物理内存进行标记的而不是虚拟内存，它设计了一个表将不同块的内存进行标记，该标记能够对内存块进行标记来保证这块内存是否被修改过了，然后通过这块内存所包含的权限等一共256位的信息决定该内存的访问权限、地址等信息。
    对于解决向后兼容这个问题，使以往使用的软件能够继续运行在CHERI上，CHERI通过提供两种运行模式来决定应用通过何种方式来访问内存空间，并提供了相应的方法支持这些应用使用CHERI的保护机制，这些上层应用在访问内存的时候都会隐式或显式的使用capability，对于读取capability的信息这一步骤来说，是由CHERI运行在的协处理器完成的，隐式的是由协处理器在读取的时候对内存标记进行检查，显式的就是由CHERI所提供的一些访问内存标记的接口实现的。
    CHERI所能够应用的方面也是非常广的：保护内存安全，对于C语言这种提供给使用者很大自由操控内存能力的语言来说，C语言的安全隐患也存在于他非常大的自由度中，CHERI能够提供给这类编程语言相应的内存保护；提供一种沙盒机制来完成分区化，CHERI这种细粒度的保护对程序的保护限制更大，保护也将更全面。
————————————comment————————————
优点：
    对于其他为了解决这种内存保护问题的设计来说，CHERI很好的解决了兼容性的问题，它能够很好的解决软件的遗留问题，因为他提供了一种沙盒机制供那些以往没有加入capability信息的上层应用在他所设计的micro-adress space中运行。并且CHERI能够在提供安全性检查的同时保证不错的额外性能损失。我认为这是本文的亮点，因为与他相比，大多数的同类设计都没办法做到很好的兼容性、较小的额外性能开销。
不足：
    对于该防御机制虽然提供了很好的特性，但是因此引入的capability也是要占用内存空间的，该论文的评价部分着重强调了他在性能方面的提升，忽略了需要的额外内存空间的评价。