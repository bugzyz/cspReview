---------------------------------summary--------------------------------------
1.本论文主要对Native Client这个针对x86的不可信代码的沙盒的设计、实现与分析做了介绍。
该设计的目的是为了浏览器应用在提升一定的计算性能的前提下保证一定的安全性，通过内外两层沙盒机制和service runtime来保证其安全。
2.对于NaCl的实现，作者主要从以下4个方面描述了他的设计思路：
    2.1.内部沙盒-作者定义了一些用于分析不可信代码安全性的规则，并将这些规则应用作为编译工具链中的一环对不可信代码进行监视；并通过一个静态分析器对这些不可信代码根据事先定义的规则进行静态的代码分析。
        2.1.1.内部规则的规则将禁止一部分的系统调用，通过这种方法能够有效的限制NaCl中的不可信代码的攻击。
        2.1.2.规定NaCl中的代码在间接跳转时将跳转地址对其到32，在每次做间接跳转时判断是否跳转地址是遵守这个规则的，若没有遵守，说明这个间接跳转是不合法的，并构造了一个可信的可间接跳转的地址集，每当程序需要进行间接跳转时通过这种方法来对跳转地址是否合法进行判断，只有判断合法才能做跳转。
        2.1.3.在直接跳转中，由于跳转的目的地址已经固定，所以可以直接对地址进行判断，若满足直接跳转目的地址是合法的，则允许跳转。        
    2.2.异常-NaCl不允许不可信代码接触到硬件异常、外部中断来保证安全。在linux、Windows中的程序通过%ss寄存器来记录段基址，并通过%esp寄存器来记录偏移，使用%esp来传递事件，通过段基址:偏移来计算出事件的地址。而由于NaCl修改了%ss寄存器，这就导致了当异常、中断出现时程序没办法有效的接收到事件且由于丢失了异常处理程序返回的地址导致进程终止，从而实现异常隔离。另一方面，由于软件异常是发生在user level上的，所以NaCl支持c++软件异常。
    2.3.service runtime-NaCl通过service runtime来提供一些底层的系统调用，他通过一个组织好的数据段来提供不可信代码到可信代码的跳转，反之亦然。他通过数据段中命名为trampoline的代码段来将段寄存器恢复为普通系统使用的段寄存器的值来允许系统调用跳转；反之，他通过springboard来做可信代码到不可信代码的跳转。
    2.4.通信-文中基于IMC做了SRPC、NPAPI的通信方式，使用类似于Unix domain socket的方式实现了一个NaCl的socket，提供了一种双向、可信的、顺序的数据包，通过SRPC、NPAPI两种通信方式中对通信过程中使用的类型进行了限制，通过该限制来保证一定的安全性。
---------------------------------comments--------------------------------------
3.我的感想：
    NaCl的提出一定是有他的一定道理的，他改进了JavaScript为直译式语言在执行中运行较慢的这一缺点， 提出了以编译式语言来执行，可以有效的提高性能。在安全方面，NaCl考虑到了不可信代码最大的安全隐患就是容易被注入恶意代码从而入侵系统，所以设置了沙盒的机制来防止不可信代码在系统中随意跳转，通过修改寄存器、编译工具链的方式来使不可信代码在编译阶段就被发现他的不符合规则的行为，能够有效的在运行该不可信代码的同时保证安全性。
    然而个人认为NaCl暂时的运用场景仍然不多，因为现在看来，大部分需要复杂、大量运算的工作一般仍是放在服务器端进行运算，且先前的大部分的网页应用都是使用JavaScript来写的，要将其都转换为NaCl并没有那么快速，这可能也是NaCl迟迟得不到发展的原因吧。